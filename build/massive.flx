export massive
import "libc" as _
import "math" as _
ffi fn srand(s: i32)
ffi fn rand() -> i32

let names0 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal0
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names0[rand() % names0.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog0 : Animal0
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation0 : Dog0
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList0<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff0()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog0 [5] {
			if i % 2 == 1   { it = alloc Dalmation0 }
			else            { it = alloc Dog0 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList0<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names1 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal1
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names1[rand() % names1.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog1 : Animal1
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation1 : Dog1
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList1<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff1()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog1 [5] {
			if i % 2 == 1   { it = alloc Dalmation1 }
			else            { it = alloc Dog1 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList1<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names2 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal2
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names2[rand() % names2.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog2 : Animal2
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation2 : Dog2
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList2<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff2()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog2 [5] {
			if i % 2 == 1   { it = alloc Dalmation2 }
			else            { it = alloc Dog2 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList2<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names3 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal3
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names3[rand() % names3.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog3 : Animal3
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation3 : Dog3
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList3<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff3()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog3 [5] {
			if i % 2 == 1   { it = alloc Dalmation3 }
			else            { it = alloc Dog3 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList3<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names4 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal4
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names4[rand() % names4.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog4 : Animal4
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation4 : Dog4
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList4<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff4()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog4 [5] {
			if i % 2 == 1   { it = alloc Dalmation4 }
			else            { it = alloc Dog4 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList4<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names5 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal5
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names5[rand() % names5.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog5 : Animal5
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation5 : Dog5
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList5<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff5()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog5 [5] {
			if i % 2 == 1   { it = alloc Dalmation5 }
			else            { it = alloc Dog5 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList5<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names6 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal6
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names6[rand() % names6.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog6 : Animal6
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation6 : Dog6
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList6<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff6()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog6 [5] {
			if i % 2 == 1   { it = alloc Dalmation6 }
			else            { it = alloc Dog6 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList6<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names7 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal7
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names7[rand() % names7.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog7 : Animal7
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation7 : Dog7
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList7<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff7()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog7 [5] {
			if i % 2 == 1   { it = alloc Dalmation7 }
			else            { it = alloc Dog7 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList7<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names8 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal8
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names8[rand() % names8.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog8 : Animal8
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation8 : Dog8
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList8<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff8()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog8 [5] {
			if i % 2 == 1   { it = alloc Dalmation8 }
			else            { it = alloc Dog8 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList8<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names9 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal9
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names9[rand() % names9.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog9 : Animal9
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation9 : Dog9
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList9<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff9()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog9 [5] {
			if i % 2 == 1   { it = alloc Dalmation9 }
			else            { it = alloc Dog9 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList9<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names10 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal10
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names10[rand() % names10.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog10 : Animal10
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation10 : Dog10
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList10<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff10()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog10 [5] {
			if i % 2 == 1   { it = alloc Dalmation10 }
			else            { it = alloc Dog10 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList10<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names11 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal11
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names11[rand() % names11.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog11 : Animal11
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation11 : Dog11
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList11<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff11()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog11 [5] {
			if i % 2 == 1   { it = alloc Dalmation11 }
			else            { it = alloc Dog11 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList11<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names12 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal12
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names12[rand() % names12.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog12 : Animal12
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation12 : Dog12
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList12<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff12()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog12 [5] {
			if i % 2 == 1   { it = alloc Dalmation12 }
			else            { it = alloc Dog12 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList12<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names13 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal13
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names13[rand() % names13.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog13 : Animal13
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation13 : Dog13
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList13<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff13()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog13 [5] {
			if i % 2 == 1   { it = alloc Dalmation13 }
			else            { it = alloc Dog13 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList13<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names14 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal14
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names14[rand() % names14.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog14 : Animal14
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation14 : Dog14
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList14<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff14()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog14 [5] {
			if i % 2 == 1   { it = alloc Dalmation14 }
			else            { it = alloc Dog14 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList14<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names15 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal15
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names15[rand() % names15.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog15 : Animal15
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation15 : Dog15
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList15<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff15()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog15 [5] {
			if i % 2 == 1   { it = alloc Dalmation15 }
			else            { it = alloc Dog15 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList15<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names16 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal16
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names16[rand() % names16.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog16 : Animal16
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation16 : Dog16
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList16<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff16()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog16 [5] {
			if i % 2 == 1   { it = alloc Dalmation16 }
			else            { it = alloc Dog16 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList16<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names17 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal17
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names17[rand() % names17.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog17 : Animal17
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation17 : Dog17
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList17<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff17()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog17 [5] {
			if i % 2 == 1   { it = alloc Dalmation17 }
			else            { it = alloc Dog17 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList17<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names18 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal18
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names18[rand() % names18.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog18 : Animal18
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation18 : Dog18
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList18<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff18()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog18 [5] {
			if i % 2 == 1   { it = alloc Dalmation18 }
			else            { it = alloc Dog18 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList18<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names19 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal19
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names19[rand() % names19.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog19 : Animal19
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation19 : Dog19
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList19<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff19()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog19 [5] {
			if i % 2 == 1   { it = alloc Dalmation19 }
			else            { it = alloc Dog19 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList19<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names20 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal20
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names20[rand() % names20.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog20 : Animal20
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation20 : Dog20
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList20<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff20()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog20 [5] {
			if i % 2 == 1   { it = alloc Dalmation20 }
			else            { it = alloc Dog20 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList20<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names21 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal21
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names21[rand() % names21.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog21 : Animal21
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation21 : Dog21
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList21<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff21()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog21 [5] {
			if i % 2 == 1   { it = alloc Dalmation21 }
			else            { it = alloc Dog21 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList21<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names22 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal22
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names22[rand() % names22.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog22 : Animal22
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation22 : Dog22
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList22<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff22()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog22 [5] {
			if i % 2 == 1   { it = alloc Dalmation22 }
			else            { it = alloc Dog22 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList22<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names23 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal23
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names23[rand() % names23.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog23 : Animal23
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation23 : Dog23
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList23<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff23()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog23 [5] {
			if i % 2 == 1   { it = alloc Dalmation23 }
			else            { it = alloc Dog23 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList23<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names24 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal24
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names24[rand() % names24.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog24 : Animal24
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation24 : Dog24
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList24<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff24()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog24 [5] {
			if i % 2 == 1   { it = alloc Dalmation24 }
			else            { it = alloc Dog24 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList24<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names25 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal25
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names25[rand() % names25.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog25 : Animal25
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation25 : Dog25
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList25<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff25()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog25 [5] {
			if i % 2 == 1   { it = alloc Dalmation25 }
			else            { it = alloc Dog25 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList25<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names26 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal26
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names26[rand() % names26.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog26 : Animal26
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation26 : Dog26
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList26<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff26()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog26 [5] {
			if i % 2 == 1   { it = alloc Dalmation26 }
			else            { it = alloc Dog26 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList26<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names27 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal27
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names27[rand() % names27.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog27 : Animal27
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation27 : Dog27
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList27<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff27()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog27 [5] {
			if i % 2 == 1   { it = alloc Dalmation27 }
			else            { it = alloc Dog27 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList27<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names28 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal28
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names28[rand() % names28.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog28 : Animal28
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation28 : Dog28
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList28<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff28()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog28 [5] {
			if i % 2 == 1   { it = alloc Dalmation28 }
			else            { it = alloc Dog28 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList28<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names29 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal29
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names29[rand() % names29.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog29 : Animal29
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation29 : Dog29
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList29<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff29()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog29 [5] {
			if i % 2 == 1   { it = alloc Dalmation29 }
			else            { it = alloc Dog29 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList29<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names30 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal30
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names30[rand() % names30.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog30 : Animal30
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation30 : Dog30
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList30<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff30()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog30 [5] {
			if i % 2 == 1   { it = alloc Dalmation30 }
			else            { it = alloc Dog30 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList30<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names31 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal31
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names31[rand() % names31.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog31 : Animal31
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation31 : Dog31
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList31<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff31()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog31 [5] {
			if i % 2 == 1   { it = alloc Dalmation31 }
			else            { it = alloc Dog31 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList31<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names32 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal32
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names32[rand() % names32.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog32 : Animal32
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation32 : Dog32
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList32<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff32()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog32 [5] {
			if i % 2 == 1   { it = alloc Dalmation32 }
			else            { it = alloc Dog32 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList32<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names33 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal33
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names33[rand() % names33.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog33 : Animal33
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation33 : Dog33
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList33<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff33()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog33 [5] {
			if i % 2 == 1   { it = alloc Dalmation33 }
			else            { it = alloc Dog33 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList33<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names34 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal34
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names34[rand() % names34.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog34 : Animal34
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation34 : Dog34
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList34<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff34()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog34 [5] {
			if i % 2 == 1   { it = alloc Dalmation34 }
			else            { it = alloc Dog34 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList34<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names35 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal35
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names35[rand() % names35.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog35 : Animal35
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation35 : Dog35
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList35<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff35()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog35 [5] {
			if i % 2 == 1   { it = alloc Dalmation35 }
			else            { it = alloc Dog35 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList35<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names36 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal36
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names36[rand() % names36.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog36 : Animal36
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation36 : Dog36
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList36<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff36()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog36 [5] {
			if i % 2 == 1   { it = alloc Dalmation36 }
			else            { it = alloc Dog36 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList36<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names37 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal37
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names37[rand() % names37.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog37 : Animal37
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation37 : Dog37
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList37<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff37()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog37 [5] {
			if i % 2 == 1   { it = alloc Dalmation37 }
			else            { it = alloc Dog37 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList37<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names38 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal38
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names38[rand() % names38.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog38 : Animal38
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation38 : Dog38
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList38<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff38()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog38 [5] {
			if i % 2 == 1   { it = alloc Dalmation38 }
			else            { it = alloc Dog38 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList38<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names39 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal39
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names39[rand() % names39.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog39 : Animal39
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation39 : Dog39
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList39<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff39()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog39 [5] {
			if i % 2 == 1   { it = alloc Dalmation39 }
			else            { it = alloc Dog39 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList39<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names40 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal40
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names40[rand() % names40.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog40 : Animal40
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation40 : Dog40
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList40<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff40()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog40 [5] {
			if i % 2 == 1   { it = alloc Dalmation40 }
			else            { it = alloc Dog40 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList40<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names41 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal41
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names41[rand() % names41.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog41 : Animal41
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation41 : Dog41
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList41<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff41()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog41 [5] {
			if i % 2 == 1   { it = alloc Dalmation41 }
			else            { it = alloc Dog41 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList41<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names42 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal42
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names42[rand() % names42.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog42 : Animal42
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation42 : Dog42
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList42<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff42()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog42 [5] {
			if i % 2 == 1   { it = alloc Dalmation42 }
			else            { it = alloc Dog42 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList42<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names43 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal43
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names43[rand() % names43.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog43 : Animal43
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation43 : Dog43
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList43<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff43()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog43 [5] {
			if i % 2 == 1   { it = alloc Dalmation43 }
			else            { it = alloc Dog43 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList43<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names44 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal44
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names44[rand() % names44.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog44 : Animal44
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation44 : Dog44
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList44<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff44()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog44 [5] {
			if i % 2 == 1   { it = alloc Dalmation44 }
			else            { it = alloc Dog44 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList44<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names45 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal45
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names45[rand() % names45.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog45 : Animal45
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation45 : Dog45
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList45<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff45()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog45 [5] {
			if i % 2 == 1   { it = alloc Dalmation45 }
			else            { it = alloc Dog45 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList45<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names46 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal46
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names46[rand() % names46.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog46 : Animal46
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation46 : Dog46
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList46<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff46()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog46 [5] {
			if i % 2 == 1   { it = alloc Dalmation46 }
			else            { it = alloc Dog46 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList46<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names47 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal47
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names47[rand() % names47.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog47 : Animal47
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation47 : Dog47
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList47<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff47()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog47 [5] {
			if i % 2 == 1   { it = alloc Dalmation47 }
			else            { it = alloc Dog47 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList47<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names48 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal48
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names48[rand() % names48.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog48 : Animal48
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation48 : Dog48
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList48<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff48()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog48 [5] {
			if i % 2 == 1   { it = alloc Dalmation48 }
			else            { it = alloc Dog48 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList48<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names49 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal49
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names49[rand() % names49.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog49 : Animal49
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation49 : Dog49
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList49<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff49()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog49 [5] {
			if i % 2 == 1   { it = alloc Dalmation49 }
			else            { it = alloc Dog49 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList49<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names50 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal50
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names50[rand() % names50.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog50 : Animal50
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation50 : Dog50
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList50<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff50()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog50 [5] {
			if i % 2 == 1   { it = alloc Dalmation50 }
			else            { it = alloc Dog50 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList50<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names51 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal51
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names51[rand() % names51.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog51 : Animal51
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation51 : Dog51
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList51<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff51()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog51 [5] {
			if i % 2 == 1   { it = alloc Dalmation51 }
			else            { it = alloc Dog51 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList51<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names52 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal52
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names52[rand() % names52.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog52 : Animal52
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation52 : Dog52
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList52<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff52()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog52 [5] {
			if i % 2 == 1   { it = alloc Dalmation52 }
			else            { it = alloc Dog52 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList52<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names53 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal53
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names53[rand() % names53.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog53 : Animal53
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation53 : Dog53
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList53<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff53()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog53 [5] {
			if i % 2 == 1   { it = alloc Dalmation53 }
			else            { it = alloc Dog53 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList53<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names54 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal54
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names54[rand() % names54.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog54 : Animal54
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation54 : Dog54
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList54<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff54()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog54 [5] {
			if i % 2 == 1   { it = alloc Dalmation54 }
			else            { it = alloc Dog54 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList54<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names55 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal55
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names55[rand() % names55.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog55 : Animal55
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation55 : Dog55
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList55<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff55()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog55 [5] {
			if i % 2 == 1   { it = alloc Dalmation55 }
			else            { it = alloc Dog55 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList55<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names56 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal56
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names56[rand() % names56.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog56 : Animal56
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation56 : Dog56
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList56<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff56()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog56 [5] {
			if i % 2 == 1   { it = alloc Dalmation56 }
			else            { it = alloc Dog56 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList56<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names57 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal57
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names57[rand() % names57.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog57 : Animal57
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation57 : Dog57
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList57<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff57()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog57 [5] {
			if i % 2 == 1   { it = alloc Dalmation57 }
			else            { it = alloc Dog57 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList57<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names58 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal58
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names58[rand() % names58.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog58 : Animal58
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation58 : Dog58
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList58<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff58()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog58 [5] {
			if i % 2 == 1   { it = alloc Dalmation58 }
			else            { it = alloc Dog58 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList58<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names59 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal59
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names59[rand() % names59.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog59 : Animal59
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation59 : Dog59
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList59<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff59()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog59 [5] {
			if i % 2 == 1   { it = alloc Dalmation59 }
			else            { it = alloc Dog59 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList59<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names60 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal60
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names60[rand() % names60.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog60 : Animal60
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation60 : Dog60
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList60<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff60()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog60 [5] {
			if i % 2 == 1   { it = alloc Dalmation60 }
			else            { it = alloc Dog60 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList60<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names61 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal61
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names61[rand() % names61.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog61 : Animal61
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation61 : Dog61
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList61<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff61()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog61 [5] {
			if i % 2 == 1   { it = alloc Dalmation61 }
			else            { it = alloc Dog61 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList61<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names62 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal62
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names62[rand() % names62.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog62 : Animal62
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation62 : Dog62
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList62<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff62()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog62 [5] {
			if i % 2 == 1   { it = alloc Dalmation62 }
			else            { it = alloc Dog62 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList62<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names63 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal63
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names63[rand() % names63.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog63 : Animal63
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation63 : Dog63
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList63<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff63()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog63 [5] {
			if i % 2 == 1   { it = alloc Dalmation63 }
			else            { it = alloc Dog63 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList63<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names64 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal64
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names64[rand() % names64.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog64 : Animal64
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation64 : Dog64
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList64<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff64()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog64 [5] {
			if i % 2 == 1   { it = alloc Dalmation64 }
			else            { it = alloc Dog64 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList64<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names65 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal65
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names65[rand() % names65.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog65 : Animal65
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation65 : Dog65
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList65<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff65()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog65 [5] {
			if i % 2 == 1   { it = alloc Dalmation65 }
			else            { it = alloc Dog65 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList65<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names66 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal66
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names66[rand() % names66.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog66 : Animal66
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation66 : Dog66
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList66<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff66()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog66 [5] {
			if i % 2 == 1   { it = alloc Dalmation66 }
			else            { it = alloc Dog66 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList66<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names67 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal67
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names67[rand() % names67.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog67 : Animal67
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation67 : Dog67
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList67<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff67()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog67 [5] {
			if i % 2 == 1   { it = alloc Dalmation67 }
			else            { it = alloc Dog67 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList67<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names68 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal68
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names68[rand() % names68.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog68 : Animal68
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation68 : Dog68
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList68<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff68()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog68 [5] {
			if i % 2 == 1   { it = alloc Dalmation68 }
			else            { it = alloc Dog68 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList68<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names69 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal69
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names69[rand() % names69.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog69 : Animal69
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation69 : Dog69
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList69<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff69()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog69 [5] {
			if i % 2 == 1   { it = alloc Dalmation69 }
			else            { it = alloc Dog69 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList69<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names70 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal70
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names70[rand() % names70.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog70 : Animal70
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation70 : Dog70
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList70<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff70()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog70 [5] {
			if i % 2 == 1   { it = alloc Dalmation70 }
			else            { it = alloc Dog70 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList70<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names71 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal71
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names71[rand() % names71.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog71 : Animal71
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation71 : Dog71
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList71<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff71()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog71 [5] {
			if i % 2 == 1   { it = alloc Dalmation71 }
			else            { it = alloc Dog71 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList71<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names72 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal72
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names72[rand() % names72.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog72 : Animal72
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation72 : Dog72
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList72<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff72()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog72 [5] {
			if i % 2 == 1   { it = alloc Dalmation72 }
			else            { it = alloc Dog72 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList72<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names73 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal73
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names73[rand() % names73.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog73 : Animal73
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation73 : Dog73
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList73<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff73()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog73 [5] {
			if i % 2 == 1   { it = alloc Dalmation73 }
			else            { it = alloc Dog73 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList73<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names74 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal74
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names74[rand() % names74.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog74 : Animal74
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation74 : Dog74
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList74<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff74()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog74 [5] {
			if i % 2 == 1   { it = alloc Dalmation74 }
			else            { it = alloc Dog74 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList74<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names75 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal75
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names75[rand() % names75.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog75 : Animal75
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation75 : Dog75
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList75<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff75()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog75 [5] {
			if i % 2 == 1   { it = alloc Dalmation75 }
			else            { it = alloc Dog75 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList75<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names76 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal76
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names76[rand() % names76.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog76 : Animal76
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation76 : Dog76
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList76<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff76()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog76 [5] {
			if i % 2 == 1   { it = alloc Dalmation76 }
			else            { it = alloc Dog76 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList76<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names77 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal77
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names77[rand() % names77.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog77 : Animal77
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation77 : Dog77
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList77<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff77()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog77 [5] {
			if i % 2 == 1   { it = alloc Dalmation77 }
			else            { it = alloc Dog77 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList77<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names78 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal78
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names78[rand() % names78.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog78 : Animal78
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation78 : Dog78
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList78<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff78()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog78 [5] {
			if i % 2 == 1   { it = alloc Dalmation78 }
			else            { it = alloc Dog78 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList78<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names79 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal79
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names79[rand() % names79.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog79 : Animal79
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation79 : Dog79
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList79<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff79()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog79 [5] {
			if i % 2 == 1   { it = alloc Dalmation79 }
			else            { it = alloc Dog79 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList79<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names80 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal80
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names80[rand() % names80.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog80 : Animal80
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation80 : Dog80
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList80<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff80()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog80 [5] {
			if i % 2 == 1   { it = alloc Dalmation80 }
			else            { it = alloc Dog80 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList80<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names81 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal81
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names81[rand() % names81.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog81 : Animal81
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation81 : Dog81
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList81<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff81()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog81 [5] {
			if i % 2 == 1   { it = alloc Dalmation81 }
			else            { it = alloc Dog81 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList81<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names82 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal82
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names82[rand() % names82.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog82 : Animal82
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation82 : Dog82
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList82<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff82()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog82 [5] {
			if i % 2 == 1   { it = alloc Dalmation82 }
			else            { it = alloc Dog82 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList82<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names83 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal83
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names83[rand() % names83.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog83 : Animal83
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation83 : Dog83
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList83<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff83()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog83 [5] {
			if i % 2 == 1   { it = alloc Dalmation83 }
			else            { it = alloc Dog83 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList83<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names84 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal84
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names84[rand() % names84.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog84 : Animal84
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation84 : Dog84
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList84<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff84()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog84 [5] {
			if i % 2 == 1   { it = alloc Dalmation84 }
			else            { it = alloc Dog84 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList84<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names85 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal85
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names85[rand() % names85.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog85 : Animal85
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation85 : Dog85
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList85<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff85()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog85 [5] {
			if i % 2 == 1   { it = alloc Dalmation85 }
			else            { it = alloc Dog85 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList85<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names86 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal86
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names86[rand() % names86.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog86 : Animal86
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation86 : Dog86
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList86<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff86()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog86 [5] {
			if i % 2 == 1   { it = alloc Dalmation86 }
			else            { it = alloc Dog86 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList86<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names87 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal87
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names87[rand() % names87.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog87 : Animal87
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation87 : Dog87
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList87<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff87()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog87 [5] {
			if i % 2 == 1   { it = alloc Dalmation87 }
			else            { it = alloc Dog87 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList87<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names88 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal88
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names88[rand() % names88.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog88 : Animal88
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation88 : Dog88
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList88<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff88()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog88 [5] {
			if i % 2 == 1   { it = alloc Dalmation88 }
			else            { it = alloc Dog88 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList88<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names89 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal89
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names89[rand() % names89.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog89 : Animal89
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation89 : Dog89
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList89<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff89()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog89 [5] {
			if i % 2 == 1   { it = alloc Dalmation89 }
			else            { it = alloc Dog89 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList89<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names90 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal90
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names90[rand() % names90.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog90 : Animal90
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation90 : Dog90
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList90<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff90()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog90 [5] {
			if i % 2 == 1   { it = alloc Dalmation90 }
			else            { it = alloc Dog90 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList90<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names91 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal91
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names91[rand() % names91.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog91 : Animal91
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation91 : Dog91
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList91<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff91()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog91 [5] {
			if i % 2 == 1   { it = alloc Dalmation91 }
			else            { it = alloc Dog91 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList91<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names92 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal92
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names92[rand() % names92.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog92 : Animal92
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation92 : Dog92
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList92<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff92()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog92 [5] {
			if i % 2 == 1   { it = alloc Dalmation92 }
			else            { it = alloc Dog92 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList92<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names93 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal93
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names93[rand() % names93.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog93 : Animal93
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation93 : Dog93
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList93<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff93()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog93 [5] {
			if i % 2 == 1   { it = alloc Dalmation93 }
			else            { it = alloc Dog93 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList93<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names94 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal94
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names94[rand() % names94.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog94 : Animal94
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation94 : Dog94
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList94<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff94()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog94 [5] {
			if i % 2 == 1   { it = alloc Dalmation94 }
			else            { it = alloc Dog94 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList94<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names95 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal95
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names95[rand() % names95.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog95 : Animal95
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation95 : Dog95
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList95<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff95()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog95 [5] {
			if i % 2 == 1   { it = alloc Dalmation95 }
			else            { it = alloc Dog95 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList95<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names96 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal96
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names96[rand() % names96.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog96 : Animal96
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation96 : Dog96
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList96<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff96()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog96 [5] {
			if i % 2 == 1   { it = alloc Dalmation96 }
			else            { it = alloc Dog96 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList96<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names97 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal97
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names97[rand() % names97.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog97 : Animal97
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation97 : Dog97
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList97<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff97()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog97 [5] {
			if i % 2 == 1   { it = alloc Dalmation97 }
			else            { it = alloc Dog97 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList97<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names98 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal98
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names98[rand() % names98.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog98 : Animal98
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation98 : Dog98
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList98<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff98()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog98 [5] {
			if i % 2 == 1   { it = alloc Dalmation98 }
			else            { it = alloc Dog98 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList98<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names99 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal99
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names99[rand() % names99.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog99 : Animal99
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation99 : Dog99
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList99<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff99()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog99 [5] {
			if i % 2 == 1   { it = alloc Dalmation99 }
			else            { it = alloc Dog99 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList99<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names100 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal100
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names100[rand() % names100.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog100 : Animal100
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation100 : Dog100
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList100<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff100()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog100 [5] {
			if i % 2 == 1   { it = alloc Dalmation100 }
			else            { it = alloc Dog100 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList100<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names101 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal101
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names101[rand() % names101.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog101 : Animal101
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation101 : Dog101
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList101<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff101()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog101 [5] {
			if i % 2 == 1   { it = alloc Dalmation101 }
			else            { it = alloc Dog101 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList101<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names102 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal102
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names102[rand() % names102.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog102 : Animal102
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation102 : Dog102
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList102<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff102()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog102 [5] {
			if i % 2 == 1   { it = alloc Dalmation102 }
			else            { it = alloc Dog102 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList102<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names103 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal103
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names103[rand() % names103.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog103 : Animal103
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation103 : Dog103
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList103<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff103()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog103 [5] {
			if i % 2 == 1   { it = alloc Dalmation103 }
			else            { it = alloc Dog103 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList103<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names104 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal104
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names104[rand() % names104.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog104 : Animal104
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation104 : Dog104
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList104<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff104()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog104 [5] {
			if i % 2 == 1   { it = alloc Dalmation104 }
			else            { it = alloc Dog104 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList104<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names105 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal105
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names105[rand() % names105.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog105 : Animal105
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation105 : Dog105
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList105<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff105()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog105 [5] {
			if i % 2 == 1   { it = alloc Dalmation105 }
			else            { it = alloc Dog105 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList105<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names106 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal106
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names106[rand() % names106.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog106 : Animal106
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation106 : Dog106
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList106<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff106()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog106 [5] {
			if i % 2 == 1   { it = alloc Dalmation106 }
			else            { it = alloc Dog106 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList106<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names107 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal107
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names107[rand() % names107.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog107 : Animal107
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation107 : Dog107
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList107<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff107()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog107 [5] {
			if i % 2 == 1   { it = alloc Dalmation107 }
			else            { it = alloc Dog107 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList107<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names108 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal108
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names108[rand() % names108.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog108 : Animal108
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation108 : Dog108
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList108<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff108()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog108 [5] {
			if i % 2 == 1   { it = alloc Dalmation108 }
			else            { it = alloc Dog108 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList108<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names109 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal109
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names109[rand() % names109.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog109 : Animal109
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation109 : Dog109
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList109<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff109()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog109 [5] {
			if i % 2 == 1   { it = alloc Dalmation109 }
			else            { it = alloc Dog109 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList109<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names110 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal110
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names110[rand() % names110.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog110 : Animal110
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation110 : Dog110
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList110<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff110()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog110 [5] {
			if i % 2 == 1   { it = alloc Dalmation110 }
			else            { it = alloc Dog110 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList110<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names111 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal111
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names111[rand() % names111.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog111 : Animal111
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation111 : Dog111
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList111<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff111()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog111 [5] {
			if i % 2 == 1   { it = alloc Dalmation111 }
			else            { it = alloc Dog111 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList111<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names112 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal112
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names112[rand() % names112.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog112 : Animal112
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation112 : Dog112
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList112<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff112()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog112 [5] {
			if i % 2 == 1   { it = alloc Dalmation112 }
			else            { it = alloc Dog112 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList112<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names113 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal113
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names113[rand() % names113.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog113 : Animal113
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation113 : Dog113
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList113<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff113()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog113 [5] {
			if i % 2 == 1   { it = alloc Dalmation113 }
			else            { it = alloc Dog113 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList113<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names114 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal114
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names114[rand() % names114.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog114 : Animal114
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation114 : Dog114
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList114<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff114()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog114 [5] {
			if i % 2 == 1   { it = alloc Dalmation114 }
			else            { it = alloc Dog114 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList114<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names115 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal115
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names115[rand() % names115.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog115 : Animal115
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation115 : Dog115
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList115<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff115()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog115 [5] {
			if i % 2 == 1   { it = alloc Dalmation115 }
			else            { it = alloc Dog115 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList115<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names116 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal116
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names116[rand() % names116.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog116 : Animal116
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation116 : Dog116
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList116<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff116()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog116 [5] {
			if i % 2 == 1   { it = alloc Dalmation116 }
			else            { it = alloc Dog116 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList116<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names117 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal117
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names117[rand() % names117.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog117 : Animal117
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation117 : Dog117
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList117<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff117()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog117 [5] {
			if i % 2 == 1   { it = alloc Dalmation117 }
			else            { it = alloc Dog117 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList117<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names118 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal118
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names118[rand() % names118.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog118 : Animal118
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation118 : Dog118
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList118<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff118()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog118 [5] {
			if i % 2 == 1   { it = alloc Dalmation118 }
			else            { it = alloc Dog118 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList118<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names119 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal119
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names119[rand() % names119.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog119 : Animal119
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation119 : Dog119
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList119<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff119()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog119 [5] {
			if i % 2 == 1   { it = alloc Dalmation119 }
			else            { it = alloc Dog119 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList119<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names120 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal120
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names120[rand() % names120.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog120 : Animal120
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation120 : Dog120
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList120<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff120()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog120 [5] {
			if i % 2 == 1   { it = alloc Dalmation120 }
			else            { it = alloc Dog120 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList120<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names121 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal121
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names121[rand() % names121.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog121 : Animal121
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation121 : Dog121
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList121<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff121()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog121 [5] {
			if i % 2 == 1   { it = alloc Dalmation121 }
			else            { it = alloc Dog121 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList121<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names122 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal122
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names122[rand() % names122.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog122 : Animal122
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation122 : Dog122
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList122<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff122()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog122 [5] {
			if i % 2 == 1   { it = alloc Dalmation122 }
			else            { it = alloc Dog122 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList122<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names123 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal123
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names123[rand() % names123.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog123 : Animal123
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation123 : Dog123
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList123<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff123()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog123 [5] {
			if i % 2 == 1   { it = alloc Dalmation123 }
			else            { it = alloc Dog123 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList123<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names124 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal124
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names124[rand() % names124.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog124 : Animal124
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation124 : Dog124
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList124<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff124()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog124 [5] {
			if i % 2 == 1   { it = alloc Dalmation124 }
			else            { it = alloc Dog124 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList124<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names125 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal125
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names125[rand() % names125.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog125 : Animal125
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation125 : Dog125
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList125<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff125()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog125 [5] {
			if i % 2 == 1   { it = alloc Dalmation125 }
			else            { it = alloc Dog125 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList125<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names126 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal126
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names126[rand() % names126.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog126 : Animal126
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation126 : Dog126
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList126<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff126()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog126 [5] {
			if i % 2 == 1   { it = alloc Dalmation126 }
			else            { it = alloc Dog126 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList126<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names127 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal127
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names127[rand() % names127.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog127 : Animal127
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation127 : Dog127
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList127<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff127()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog127 [5] {
			if i % 2 == 1   { it = alloc Dalmation127 }
			else            { it = alloc Dog127 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList127<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names128 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal128
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names128[rand() % names128.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog128 : Animal128
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation128 : Dog128
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList128<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff128()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog128 [5] {
			if i % 2 == 1   { it = alloc Dalmation128 }
			else            { it = alloc Dog128 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList128<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names129 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal129
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names129[rand() % names129.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog129 : Animal129
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation129 : Dog129
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList129<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff129()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog129 [5] {
			if i % 2 == 1   { it = alloc Dalmation129 }
			else            { it = alloc Dog129 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList129<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names130 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal130
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names130[rand() % names130.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog130 : Animal130
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation130 : Dog130
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList130<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff130()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog130 [5] {
			if i % 2 == 1   { it = alloc Dalmation130 }
			else            { it = alloc Dog130 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList130<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names131 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal131
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names131[rand() % names131.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog131 : Animal131
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation131 : Dog131
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList131<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff131()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog131 [5] {
			if i % 2 == 1   { it = alloc Dalmation131 }
			else            { it = alloc Dog131 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList131<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names132 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal132
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names132[rand() % names132.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog132 : Animal132
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation132 : Dog132
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList132<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff132()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog132 [5] {
			if i % 2 == 1   { it = alloc Dalmation132 }
			else            { it = alloc Dog132 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList132<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names133 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal133
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names133[rand() % names133.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog133 : Animal133
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation133 : Dog133
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList133<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff133()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog133 [5] {
			if i % 2 == 1   { it = alloc Dalmation133 }
			else            { it = alloc Dog133 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList133<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names134 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal134
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names134[rand() % names134.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog134 : Animal134
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation134 : Dog134
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList134<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff134()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog134 [5] {
			if i % 2 == 1   { it = alloc Dalmation134 }
			else            { it = alloc Dog134 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList134<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names135 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal135
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names135[rand() % names135.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog135 : Animal135
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation135 : Dog135
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList135<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff135()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog135 [5] {
			if i % 2 == 1   { it = alloc Dalmation135 }
			else            { it = alloc Dog135 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList135<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names136 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal136
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names136[rand() % names136.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog136 : Animal136
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation136 : Dog136
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList136<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff136()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog136 [5] {
			if i % 2 == 1   { it = alloc Dalmation136 }
			else            { it = alloc Dog136 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList136<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names137 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal137
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names137[rand() % names137.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog137 : Animal137
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation137 : Dog137
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList137<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff137()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog137 [5] {
			if i % 2 == 1   { it = alloc Dalmation137 }
			else            { it = alloc Dog137 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList137<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names138 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal138
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names138[rand() % names138.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog138 : Animal138
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation138 : Dog138
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList138<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff138()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog138 [5] {
			if i % 2 == 1   { it = alloc Dalmation138 }
			else            { it = alloc Dog138 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList138<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names139 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal139
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names139[rand() % names139.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog139 : Animal139
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation139 : Dog139
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList139<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff139()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog139 [5] {
			if i % 2 == 1   { it = alloc Dalmation139 }
			else            { it = alloc Dog139 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList139<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names140 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal140
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names140[rand() % names140.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog140 : Animal140
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation140 : Dog140
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList140<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff140()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog140 [5] {
			if i % 2 == 1   { it = alloc Dalmation140 }
			else            { it = alloc Dog140 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList140<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names141 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal141
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names141[rand() % names141.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog141 : Animal141
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation141 : Dog141
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList141<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff141()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog141 [5] {
			if i % 2 == 1   { it = alloc Dalmation141 }
			else            { it = alloc Dog141 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList141<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names142 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal142
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names142[rand() % names142.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog142 : Animal142
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation142 : Dog142
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList142<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff142()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog142 [5] {
			if i % 2 == 1   { it = alloc Dalmation142 }
			else            { it = alloc Dog142 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList142<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names143 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal143
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names143[rand() % names143.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog143 : Animal143
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation143 : Dog143
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList143<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff143()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog143 [5] {
			if i % 2 == 1   { it = alloc Dalmation143 }
			else            { it = alloc Dog143 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList143<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names144 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal144
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names144[rand() % names144.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog144 : Animal144
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation144 : Dog144
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList144<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff144()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog144 [5] {
			if i % 2 == 1   { it = alloc Dalmation144 }
			else            { it = alloc Dog144 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList144<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names145 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal145
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names145[rand() % names145.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog145 : Animal145
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation145 : Dog145
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList145<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff145()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog145 [5] {
			if i % 2 == 1   { it = alloc Dalmation145 }
			else            { it = alloc Dog145 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList145<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names146 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal146
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names146[rand() % names146.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog146 : Animal146
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation146 : Dog146
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList146<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff146()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog146 [5] {
			if i % 2 == 1   { it = alloc Dalmation146 }
			else            { it = alloc Dog146 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList146<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names147 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal147
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names147[rand() % names147.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog147 : Animal147
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation147 : Dog147
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList147<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff147()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog147 [5] {
			if i % 2 == 1   { it = alloc Dalmation147 }
			else            { it = alloc Dog147 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList147<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names148 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal148
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names148[rand() % names148.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog148 : Animal148
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation148 : Dog148
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList148<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff148()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog148 [5] {
			if i % 2 == 1   { it = alloc Dalmation148 }
			else            { it = alloc Dog148 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList148<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names149 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal149
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names149[rand() % names149.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog149 : Animal149
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation149 : Dog149
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList149<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff149()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog149 [5] {
			if i % 2 == 1   { it = alloc Dalmation149 }
			else            { it = alloc Dog149 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList149<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names150 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal150
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names150[rand() % names150.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog150 : Animal150
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation150 : Dog150
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList150<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff150()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog150 [5] {
			if i % 2 == 1   { it = alloc Dalmation150 }
			else            { it = alloc Dog150 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList150<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names151 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal151
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names151[rand() % names151.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog151 : Animal151
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation151 : Dog151
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList151<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff151()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog151 [5] {
			if i % 2 == 1   { it = alloc Dalmation151 }
			else            { it = alloc Dog151 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList151<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names152 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal152
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names152[rand() % names152.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog152 : Animal152
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation152 : Dog152
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList152<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff152()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog152 [5] {
			if i % 2 == 1   { it = alloc Dalmation152 }
			else            { it = alloc Dog152 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList152<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names153 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal153
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names153[rand() % names153.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog153 : Animal153
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation153 : Dog153
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList153<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff153()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog153 [5] {
			if i % 2 == 1   { it = alloc Dalmation153 }
			else            { it = alloc Dog153 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList153<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names154 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal154
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names154[rand() % names154.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog154 : Animal154
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation154 : Dog154
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList154<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff154()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog154 [5] {
			if i % 2 == 1   { it = alloc Dalmation154 }
			else            { it = alloc Dog154 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList154<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names155 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal155
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names155[rand() % names155.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog155 : Animal155
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation155 : Dog155
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList155<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff155()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog155 [5] {
			if i % 2 == 1   { it = alloc Dalmation155 }
			else            { it = alloc Dog155 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList155<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names156 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal156
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names156[rand() % names156.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog156 : Animal156
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation156 : Dog156
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList156<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff156()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog156 [5] {
			if i % 2 == 1   { it = alloc Dalmation156 }
			else            { it = alloc Dog156 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList156<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names157 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal157
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names157[rand() % names157.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog157 : Animal157
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation157 : Dog157
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList157<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff157()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog157 [5] {
			if i % 2 == 1   { it = alloc Dalmation157 }
			else            { it = alloc Dog157 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList157<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names158 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal158
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names158[rand() % names158.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog158 : Animal158
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation158 : Dog158
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList158<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff158()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog158 [5] {
			if i % 2 == 1   { it = alloc Dalmation158 }
			else            { it = alloc Dog158 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList158<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names159 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal159
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names159[rand() % names159.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog159 : Animal159
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation159 : Dog159
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList159<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff159()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog159 [5] {
			if i % 2 == 1   { it = alloc Dalmation159 }
			else            { it = alloc Dog159 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList159<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names160 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal160
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names160[rand() % names160.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog160 : Animal160
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation160 : Dog160
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList160<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff160()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog160 [5] {
			if i % 2 == 1   { it = alloc Dalmation160 }
			else            { it = alloc Dog160 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList160<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names161 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal161
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names161[rand() % names161.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog161 : Animal161
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation161 : Dog161
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList161<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff161()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog161 [5] {
			if i % 2 == 1   { it = alloc Dalmation161 }
			else            { it = alloc Dog161 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList161<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names162 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal162
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names162[rand() % names162.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog162 : Animal162
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation162 : Dog162
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList162<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff162()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog162 [5] {
			if i % 2 == 1   { it = alloc Dalmation162 }
			else            { it = alloc Dog162 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList162<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names163 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal163
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names163[rand() % names163.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog163 : Animal163
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation163 : Dog163
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList163<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff163()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog163 [5] {
			if i % 2 == 1   { it = alloc Dalmation163 }
			else            { it = alloc Dog163 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList163<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names164 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal164
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names164[rand() % names164.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog164 : Animal164
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation164 : Dog164
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList164<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff164()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog164 [5] {
			if i % 2 == 1   { it = alloc Dalmation164 }
			else            { it = alloc Dog164 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList164<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names165 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal165
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names165[rand() % names165.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog165 : Animal165
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation165 : Dog165
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList165<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff165()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog165 [5] {
			if i % 2 == 1   { it = alloc Dalmation165 }
			else            { it = alloc Dog165 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList165<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names166 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal166
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names166[rand() % names166.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog166 : Animal166
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation166 : Dog166
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList166<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff166()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog166 [5] {
			if i % 2 == 1   { it = alloc Dalmation166 }
			else            { it = alloc Dog166 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList166<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names167 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal167
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names167[rand() % names167.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog167 : Animal167
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation167 : Dog167
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList167<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff167()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog167 [5] {
			if i % 2 == 1   { it = alloc Dalmation167 }
			else            { it = alloc Dog167 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList167<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names168 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal168
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names168[rand() % names168.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog168 : Animal168
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation168 : Dog168
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList168<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff168()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog168 [5] {
			if i % 2 == 1   { it = alloc Dalmation168 }
			else            { it = alloc Dog168 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList168<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names169 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal169
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names169[rand() % names169.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog169 : Animal169
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation169 : Dog169
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList169<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff169()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog169 [5] {
			if i % 2 == 1   { it = alloc Dalmation169 }
			else            { it = alloc Dog169 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList169<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names170 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal170
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names170[rand() % names170.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog170 : Animal170
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation170 : Dog170
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList170<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff170()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog170 [5] {
			if i % 2 == 1   { it = alloc Dalmation170 }
			else            { it = alloc Dog170 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList170<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names171 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal171
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names171[rand() % names171.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog171 : Animal171
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation171 : Dog171
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList171<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff171()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog171 [5] {
			if i % 2 == 1   { it = alloc Dalmation171 }
			else            { it = alloc Dog171 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList171<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names172 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal172
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names172[rand() % names172.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog172 : Animal172
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation172 : Dog172
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList172<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff172()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog172 [5] {
			if i % 2 == 1   { it = alloc Dalmation172 }
			else            { it = alloc Dog172 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList172<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names173 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal173
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names173[rand() % names173.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog173 : Animal173
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation173 : Dog173
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList173<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff173()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog173 [5] {
			if i % 2 == 1   { it = alloc Dalmation173 }
			else            { it = alloc Dog173 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList173<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names174 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal174
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names174[rand() % names174.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog174 : Animal174
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation174 : Dog174
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList174<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff174()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog174 [5] {
			if i % 2 == 1   { it = alloc Dalmation174 }
			else            { it = alloc Dog174 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList174<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names175 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal175
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names175[rand() % names175.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog175 : Animal175
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation175 : Dog175
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList175<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff175()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog175 [5] {
			if i % 2 == 1   { it = alloc Dalmation175 }
			else            { it = alloc Dog175 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList175<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names176 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal176
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names176[rand() % names176.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog176 : Animal176
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation176 : Dog176
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList176<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff176()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog176 [5] {
			if i % 2 == 1   { it = alloc Dalmation176 }
			else            { it = alloc Dog176 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList176<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names177 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal177
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names177[rand() % names177.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog177 : Animal177
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation177 : Dog177
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList177<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff177()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog177 [5] {
			if i % 2 == 1   { it = alloc Dalmation177 }
			else            { it = alloc Dog177 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList177<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names178 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal178
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names178[rand() % names178.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog178 : Animal178
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation178 : Dog178
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList178<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff178()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog178 [5] {
			if i % 2 == 1   { it = alloc Dalmation178 }
			else            { it = alloc Dog178 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList178<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names179 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal179
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names179[rand() % names179.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog179 : Animal179
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation179 : Dog179
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList179<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff179()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog179 [5] {
			if i % 2 == 1   { it = alloc Dalmation179 }
			else            { it = alloc Dog179 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList179<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names180 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal180
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names180[rand() % names180.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog180 : Animal180
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation180 : Dog180
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList180<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff180()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog180 [5] {
			if i % 2 == 1   { it = alloc Dalmation180 }
			else            { it = alloc Dog180 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList180<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names181 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal181
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names181[rand() % names181.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog181 : Animal181
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation181 : Dog181
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList181<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff181()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog181 [5] {
			if i % 2 == 1   { it = alloc Dalmation181 }
			else            { it = alloc Dog181 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList181<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names182 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal182
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names182[rand() % names182.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog182 : Animal182
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation182 : Dog182
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList182<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff182()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog182 [5] {
			if i % 2 == 1   { it = alloc Dalmation182 }
			else            { it = alloc Dog182 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList182<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names183 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal183
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names183[rand() % names183.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog183 : Animal183
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation183 : Dog183
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList183<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff183()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog183 [5] {
			if i % 2 == 1   { it = alloc Dalmation183 }
			else            { it = alloc Dog183 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList183<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names184 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal184
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names184[rand() % names184.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog184 : Animal184
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation184 : Dog184
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList184<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff184()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog184 [5] {
			if i % 2 == 1   { it = alloc Dalmation184 }
			else            { it = alloc Dog184 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList184<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names185 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal185
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names185[rand() % names185.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog185 : Animal185
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation185 : Dog185
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList185<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff185()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog185 [5] {
			if i % 2 == 1   { it = alloc Dalmation185 }
			else            { it = alloc Dog185 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList185<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names186 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal186
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names186[rand() % names186.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog186 : Animal186
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation186 : Dog186
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList186<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff186()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog186 [5] {
			if i % 2 == 1   { it = alloc Dalmation186 }
			else            { it = alloc Dog186 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList186<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names187 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal187
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names187[rand() % names187.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog187 : Animal187
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation187 : Dog187
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList187<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff187()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog187 [5] {
			if i % 2 == 1   { it = alloc Dalmation187 }
			else            { it = alloc Dog187 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList187<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names188 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal188
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names188[rand() % names188.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog188 : Animal188
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation188 : Dog188
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList188<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff188()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog188 [5] {
			if i % 2 == 1   { it = alloc Dalmation188 }
			else            { it = alloc Dog188 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList188<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names189 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal189
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names189[rand() % names189.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog189 : Animal189
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation189 : Dog189
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList189<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff189()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog189 [5] {
			if i % 2 == 1   { it = alloc Dalmation189 }
			else            { it = alloc Dog189 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList189<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names190 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal190
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names190[rand() % names190.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog190 : Animal190
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation190 : Dog190
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList190<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff190()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog190 [5] {
			if i % 2 == 1   { it = alloc Dalmation190 }
			else            { it = alloc Dog190 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList190<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names191 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal191
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names191[rand() % names191.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog191 : Animal191
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation191 : Dog191
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList191<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff191()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog191 [5] {
			if i % 2 == 1   { it = alloc Dalmation191 }
			else            { it = alloc Dog191 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList191<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names192 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal192
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names192[rand() % names192.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog192 : Animal192
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation192 : Dog192
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList192<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff192()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog192 [5] {
			if i % 2 == 1   { it = alloc Dalmation192 }
			else            { it = alloc Dog192 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList192<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names193 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal193
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names193[rand() % names193.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog193 : Animal193
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation193 : Dog193
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList193<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff193()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog193 [5] {
			if i % 2 == 1   { it = alloc Dalmation193 }
			else            { it = alloc Dog193 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList193<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names194 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal194
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names194[rand() % names194.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog194 : Animal194
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation194 : Dog194
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList194<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff194()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog194 [5] {
			if i % 2 == 1   { it = alloc Dalmation194 }
			else            { it = alloc Dog194 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList194<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names195 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal195
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names195[rand() % names195.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog195 : Animal195
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation195 : Dog195
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList195<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff195()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog195 [5] {
			if i % 2 == 1   { it = alloc Dalmation195 }
			else            { it = alloc Dog195 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList195<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names196 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal196
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names196[rand() % names196.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog196 : Animal196
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation196 : Dog196
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList196<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff196()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog196 [5] {
			if i % 2 == 1   { it = alloc Dalmation196 }
			else            { it = alloc Dog196 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList196<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names197 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal197
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names197[rand() % names197.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog197 : Animal197
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation197 : Dog197
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList197<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff197()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog197 [5] {
			if i % 2 == 1   { it = alloc Dalmation197 }
			else            { it = alloc Dog197 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList197<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names198 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal198
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names198[rand() % names198.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog198 : Animal198
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation198 : Dog198
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList198<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff198()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog198 [5] {
			if i % 2 == 1   { it = alloc Dalmation198 }
			else            { it = alloc Dog198 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList198<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names199 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal199
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names199[rand() % names199.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog199 : Animal199
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation199 : Dog199
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList199<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff199()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog199 [5] {
			if i % 2 == 1   { it = alloc Dalmation199 }
			else            { it = alloc Dog199 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList199<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names200 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal200
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names200[rand() % names200.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog200 : Animal200
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation200 : Dog200
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList200<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff200()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog200 [5] {
			if i % 2 == 1   { it = alloc Dalmation200 }
			else            { it = alloc Dog200 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList200<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names201 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal201
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names201[rand() % names201.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog201 : Animal201
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation201 : Dog201
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList201<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff201()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog201 [5] {
			if i % 2 == 1   { it = alloc Dalmation201 }
			else            { it = alloc Dog201 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList201<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names202 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal202
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names202[rand() % names202.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog202 : Animal202
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation202 : Dog202
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList202<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff202()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog202 [5] {
			if i % 2 == 1   { it = alloc Dalmation202 }
			else            { it = alloc Dog202 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList202<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names203 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal203
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names203[rand() % names203.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog203 : Animal203
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation203 : Dog203
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList203<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff203()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog203 [5] {
			if i % 2 == 1   { it = alloc Dalmation203 }
			else            { it = alloc Dog203 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList203<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names204 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal204
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names204[rand() % names204.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog204 : Animal204
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation204 : Dog204
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList204<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff204()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog204 [5] {
			if i % 2 == 1   { it = alloc Dalmation204 }
			else            { it = alloc Dog204 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList204<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names205 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal205
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names205[rand() % names205.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog205 : Animal205
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation205 : Dog205
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList205<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff205()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog205 [5] {
			if i % 2 == 1   { it = alloc Dalmation205 }
			else            { it = alloc Dog205 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList205<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names206 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal206
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names206[rand() % names206.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog206 : Animal206
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation206 : Dog206
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList206<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff206()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog206 [5] {
			if i % 2 == 1   { it = alloc Dalmation206 }
			else            { it = alloc Dog206 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList206<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names207 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal207
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names207[rand() % names207.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog207 : Animal207
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation207 : Dog207
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList207<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff207()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog207 [5] {
			if i % 2 == 1   { it = alloc Dalmation207 }
			else            { it = alloc Dog207 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList207<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names208 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal208
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names208[rand() % names208.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog208 : Animal208
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation208 : Dog208
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList208<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff208()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog208 [5] {
			if i % 2 == 1   { it = alloc Dalmation208 }
			else            { it = alloc Dog208 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList208<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names209 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal209
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names209[rand() % names209.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog209 : Animal209
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation209 : Dog209
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList209<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff209()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog209 [5] {
			if i % 2 == 1   { it = alloc Dalmation209 }
			else            { it = alloc Dog209 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList209<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names210 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal210
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names210[rand() % names210.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog210 : Animal210
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation210 : Dog210
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList210<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff210()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog210 [5] {
			if i % 2 == 1   { it = alloc Dalmation210 }
			else            { it = alloc Dog210 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList210<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names211 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal211
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names211[rand() % names211.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog211 : Animal211
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation211 : Dog211
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList211<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff211()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog211 [5] {
			if i % 2 == 1   { it = alloc Dalmation211 }
			else            { it = alloc Dog211 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList211<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names212 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal212
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names212[rand() % names212.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog212 : Animal212
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation212 : Dog212
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList212<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff212()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog212 [5] {
			if i % 2 == 1   { it = alloc Dalmation212 }
			else            { it = alloc Dog212 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList212<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names213 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal213
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names213[rand() % names213.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog213 : Animal213
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation213 : Dog213
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList213<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff213()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog213 [5] {
			if i % 2 == 1   { it = alloc Dalmation213 }
			else            { it = alloc Dog213 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList213<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names214 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal214
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names214[rand() % names214.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog214 : Animal214
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation214 : Dog214
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList214<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff214()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog214 [5] {
			if i % 2 == 1   { it = alloc Dalmation214 }
			else            { it = alloc Dog214 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList214<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names215 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal215
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names215[rand() % names215.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog215 : Animal215
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation215 : Dog215
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList215<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff215()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog215 [5] {
			if i % 2 == 1   { it = alloc Dalmation215 }
			else            { it = alloc Dog215 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList215<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names216 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal216
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names216[rand() % names216.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog216 : Animal216
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation216 : Dog216
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList216<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff216()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog216 [5] {
			if i % 2 == 1   { it = alloc Dalmation216 }
			else            { it = alloc Dog216 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList216<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names217 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal217
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names217[rand() % names217.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog217 : Animal217
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation217 : Dog217
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList217<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff217()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog217 [5] {
			if i % 2 == 1   { it = alloc Dalmation217 }
			else            { it = alloc Dog217 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList217<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names218 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal218
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names218[rand() % names218.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog218 : Animal218
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation218 : Dog218
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList218<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff218()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog218 [5] {
			if i % 2 == 1   { it = alloc Dalmation218 }
			else            { it = alloc Dog218 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList218<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names219 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal219
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names219[rand() % names219.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog219 : Animal219
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation219 : Dog219
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList219<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff219()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog219 [5] {
			if i % 2 == 1   { it = alloc Dalmation219 }
			else            { it = alloc Dog219 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList219<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names220 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal220
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names220[rand() % names220.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog220 : Animal220
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation220 : Dog220
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList220<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff220()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog220 [5] {
			if i % 2 == 1   { it = alloc Dalmation220 }
			else            { it = alloc Dog220 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList220<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names221 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal221
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names221[rand() % names221.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog221 : Animal221
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation221 : Dog221
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList221<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff221()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog221 [5] {
			if i % 2 == 1   { it = alloc Dalmation221 }
			else            { it = alloc Dog221 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList221<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names222 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal222
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names222[rand() % names222.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog222 : Animal222
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation222 : Dog222
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList222<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff222()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog222 [5] {
			if i % 2 == 1   { it = alloc Dalmation222 }
			else            { it = alloc Dog222 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList222<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names223 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal223
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names223[rand() % names223.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog223 : Animal223
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation223 : Dog223
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList223<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff223()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog223 [5] {
			if i % 2 == 1   { it = alloc Dalmation223 }
			else            { it = alloc Dog223 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList223<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names224 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal224
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names224[rand() % names224.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog224 : Animal224
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation224 : Dog224
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList224<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff224()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog224 [5] {
			if i % 2 == 1   { it = alloc Dalmation224 }
			else            { it = alloc Dog224 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList224<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names225 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal225
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names225[rand() % names225.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog225 : Animal225
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation225 : Dog225
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList225<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff225()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog225 [5] {
			if i % 2 == 1   { it = alloc Dalmation225 }
			else            { it = alloc Dog225 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList225<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names226 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal226
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names226[rand() % names226.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog226 : Animal226
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation226 : Dog226
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList226<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff226()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog226 [5] {
			if i % 2 == 1   { it = alloc Dalmation226 }
			else            { it = alloc Dog226 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList226<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names227 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal227
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names227[rand() % names227.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog227 : Animal227
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation227 : Dog227
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList227<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff227()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog227 [5] {
			if i % 2 == 1   { it = alloc Dalmation227 }
			else            { it = alloc Dog227 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList227<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names228 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal228
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names228[rand() % names228.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog228 : Animal228
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation228 : Dog228
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList228<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff228()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog228 [5] {
			if i % 2 == 1   { it = alloc Dalmation228 }
			else            { it = alloc Dog228 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList228<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names229 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal229
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names229[rand() % names229.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog229 : Animal229
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation229 : Dog229
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList229<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff229()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog229 [5] {
			if i % 2 == 1   { it = alloc Dalmation229 }
			else            { it = alloc Dog229 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList229<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names230 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal230
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names230[rand() % names230.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog230 : Animal230
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation230 : Dog230
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList230<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff230()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog230 [5] {
			if i % 2 == 1   { it = alloc Dalmation230 }
			else            { it = alloc Dog230 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList230<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names231 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal231
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names231[rand() % names231.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog231 : Animal231
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation231 : Dog231
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList231<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff231()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog231 [5] {
			if i % 2 == 1   { it = alloc Dalmation231 }
			else            { it = alloc Dog231 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList231<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names232 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal232
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names232[rand() % names232.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog232 : Animal232
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation232 : Dog232
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList232<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff232()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog232 [5] {
			if i % 2 == 1   { it = alloc Dalmation232 }
			else            { it = alloc Dog232 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList232<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names233 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal233
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names233[rand() % names233.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog233 : Animal233
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation233 : Dog233
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList233<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff233()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog233 [5] {
			if i % 2 == 1   { it = alloc Dalmation233 }
			else            { it = alloc Dog233 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList233<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names234 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal234
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names234[rand() % names234.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog234 : Animal234
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation234 : Dog234
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList234<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff234()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog234 [5] {
			if i % 2 == 1   { it = alloc Dalmation234 }
			else            { it = alloc Dog234 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList234<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names235 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal235
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names235[rand() % names235.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog235 : Animal235
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation235 : Dog235
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList235<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff235()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog235 [5] {
			if i % 2 == 1   { it = alloc Dalmation235 }
			else            { it = alloc Dog235 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList235<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names236 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal236
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names236[rand() % names236.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog236 : Animal236
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation236 : Dog236
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList236<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff236()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog236 [5] {
			if i % 2 == 1   { it = alloc Dalmation236 }
			else            { it = alloc Dog236 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList236<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names237 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal237
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names237[rand() % names237.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog237 : Animal237
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation237 : Dog237
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList237<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff237()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog237 [5] {
			if i % 2 == 1   { it = alloc Dalmation237 }
			else            { it = alloc Dog237 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList237<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names238 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal238
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names238[rand() % names238.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog238 : Animal238
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation238 : Dog238
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList238<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff238()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog238 [5] {
			if i % 2 == 1   { it = alloc Dalmation238 }
			else            { it = alloc Dog238 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList238<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names239 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal239
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names239[rand() % names239.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog239 : Animal239
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation239 : Dog239
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList239<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff239()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog239 [5] {
			if i % 2 == 1   { it = alloc Dalmation239 }
			else            { it = alloc Dog239 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList239<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names240 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal240
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names240[rand() % names240.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog240 : Animal240
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation240 : Dog240
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList240<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff240()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog240 [5] {
			if i % 2 == 1   { it = alloc Dalmation240 }
			else            { it = alloc Dog240 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList240<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names241 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal241
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names241[rand() % names241.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog241 : Animal241
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation241 : Dog241
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList241<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff241()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog241 [5] {
			if i % 2 == 1   { it = alloc Dalmation241 }
			else            { it = alloc Dog241 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList241<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names242 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal242
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names242[rand() % names242.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog242 : Animal242
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation242 : Dog242
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList242<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff242()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog242 [5] {
			if i % 2 == 1   { it = alloc Dalmation242 }
			else            { it = alloc Dog242 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList242<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names243 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal243
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names243[rand() % names243.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog243 : Animal243
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation243 : Dog243
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList243<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff243()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog243 [5] {
			if i % 2 == 1   { it = alloc Dalmation243 }
			else            { it = alloc Dog243 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList243<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names244 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal244
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names244[rand() % names244.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog244 : Animal244
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation244 : Dog244
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList244<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff244()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog244 [5] {
			if i % 2 == 1   { it = alloc Dalmation244 }
			else            { it = alloc Dog244 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList244<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names245 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal245
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names245[rand() % names245.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog245 : Animal245
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation245 : Dog245
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList245<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff245()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog245 [5] {
			if i % 2 == 1   { it = alloc Dalmation245 }
			else            { it = alloc Dog245 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList245<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names246 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal246
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names246[rand() % names246.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog246 : Animal246
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation246 : Dog246
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList246<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff246()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog246 [5] {
			if i % 2 == 1   { it = alloc Dalmation246 }
			else            { it = alloc Dog246 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList246<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names247 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal247
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names247[rand() % names247.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog247 : Animal247
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation247 : Dog247
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList247<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff247()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog247 [5] {
			if i % 2 == 1   { it = alloc Dalmation247 }
			else            { it = alloc Dog247 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList247<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names248 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal248
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names248[rand() % names248.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog248 : Animal248
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation248 : Dog248
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList248<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff248()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog248 [5] {
			if i % 2 == 1   { it = alloc Dalmation248 }
			else            { it = alloc Dog248 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList248<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names249 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal249
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names249[rand() % names249.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog249 : Animal249
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation249 : Dog249
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList249<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff249()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog249 [5] {
			if i % 2 == 1   { it = alloc Dalmation249 }
			else            { it = alloc Dog249 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList249<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names250 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal250
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names250[rand() % names250.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog250 : Animal250
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation250 : Dog250
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList250<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff250()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog250 [5] {
			if i % 2 == 1   { it = alloc Dalmation250 }
			else            { it = alloc Dog250 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList250<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names251 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal251
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names251[rand() % names251.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog251 : Animal251
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation251 : Dog251
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList251<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff251()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog251 [5] {
			if i % 2 == 1   { it = alloc Dalmation251 }
			else            { it = alloc Dog251 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList251<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names252 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal252
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names252[rand() % names252.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog252 : Animal252
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation252 : Dog252
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList252<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff252()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog252 [5] {
			if i % 2 == 1   { it = alloc Dalmation252 }
			else            { it = alloc Dog252 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList252<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names253 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal253
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names253[rand() % names253.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog253 : Animal253
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation253 : Dog253
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList253<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff253()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog253 [5] {
			if i % 2 == 1   { it = alloc Dalmation253 }
			else            { it = alloc Dog253 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList253<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names254 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal254
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names254[rand() % names254.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog254 : Animal254
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation254 : Dog254
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList254<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff254()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog254 [5] {
			if i % 2 == 1   { it = alloc Dalmation254 }
			else            { it = alloc Dog254 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList254<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}


let names255 = [ "max", "ollie", "coco", "piper", "tim", "bill", "alex", "ron", "isaac", "jim" ]

class Animal255
{
	init(w: f64)
	{
		// printf("make animal w = %f\n", w)
		weight = w
		name = names255[rand() % names255.length]
	}

	virtual fn makeNoise()
	{
		printf("some generic sound\n")
	}

	var name: str
	var weight: f64
	var cute: bool = true
}

class Dog255 : Animal255
{
	init() : super(w: 300)
	{
		// printf("make dog (w = %f)\n", weight)
	}

	override fn makeNoise()
	{
		printf("bark bark (%f)\n", weight)
	}

	virtual fn wag()
	{
		printf("wagging tail of length %d\n", tail)
	}

	var tail: int = 37
}

class Dalmation255 : Dog255
{
	init() : super()
	{
		printf("make dalmation\n")
	}

	override fn wag()
	{
		printf("dalmation wags %d\n", tail)
	}

	var numSpots: int
}


class LinkedList255<T>
{
	struct Node
	{
		var data: T

		var prev: &Node
		var next: &Node
	}

	var head: &Node
	var tail: &Node

	var count: int

	init()
	{
	}

	mut fn insert(thing: T)
	{
		var nn = alloc mut Node (data: thing, prev: null, next: null)

		if head == null { head = nn; tail = nn }
		else
		{
			var ot = tail as mut
			tail = nn

			nn.prev = ot
			ot.next = nn
		}

		count += 1
	}

	static fn hello() -> T { printf("hi\n"); return 10 }
}




fn stuff255()
{
	do {
		// don't question.
		srand(284811)

		// fn test() -> f64 { printf("hi\n"); return 31.51 }

		let dogs = alloc &Dog255 [5] {
			if i % 2 == 1   { it = alloc Dalmation255 }
			else            { it = alloc Dog255 }
		}

		for dog, i in dogs {
			printf("%d: %s - ", i, dog.name)
			dog.wag()
		}
	}


	do {
		var list: LinkedList255<T: int>

		list.insert(10)
		list.insert(20)
		list.insert(30)
		list.insert(40)

		var head = list.head
		while(head)
		{
			printf("%d\n", head.data)
			head = head.next
		}
	}
}

@entry fn main() -> i32 {
	stuff0()
	stuff1()
	stuff2()
	stuff3()
	stuff4()
	stuff5()
	stuff6()
	stuff7()
	stuff8()
	stuff9()
	stuff10()
	stuff11()
	stuff12()
	stuff13()
	stuff14()
	stuff15()
	stuff16()
	stuff17()
	stuff18()
	stuff19()
	stuff20()
	stuff21()
	stuff22()
	stuff23()
	stuff24()
	stuff25()
	stuff26()
	stuff27()
	stuff28()
	stuff29()
	stuff30()
	stuff31()
	stuff32()
	stuff33()
	stuff34()
	stuff35()
	stuff36()
	stuff37()
	stuff38()
	stuff39()
	stuff40()
	stuff41()
	stuff42()
	stuff43()
	stuff44()
	stuff45()
	stuff46()
	stuff47()
	stuff48()
	stuff49()
	stuff50()
	stuff51()
	stuff52()
	stuff53()
	stuff54()
	stuff55()
	stuff56()
	stuff57()
	stuff58()
	stuff59()
	stuff60()
	stuff61()
	stuff62()
	stuff63()
	stuff64()
	stuff65()
	stuff66()
	stuff67()
	stuff68()
	stuff69()
	stuff70()
	stuff71()
	stuff72()
	stuff73()
	stuff74()
	stuff75()
	stuff76()
	stuff77()
	stuff78()
	stuff79()
	stuff80()
	stuff81()
	stuff82()
	stuff83()
	stuff84()
	stuff85()
	stuff86()
	stuff87()
	stuff88()
	stuff89()
	stuff90()
	stuff91()
	stuff92()
	stuff93()
	stuff94()
	stuff95()
	stuff96()
	stuff97()
	stuff98()
	stuff99()
	stuff100()
	stuff101()
	stuff102()
	stuff103()
	stuff104()
	stuff105()
	stuff106()
	stuff107()
	stuff108()
	stuff109()
	stuff110()
	stuff111()
	stuff112()
	stuff113()
	stuff114()
	stuff115()
	stuff116()
	stuff117()
	stuff118()
	stuff119()
	stuff120()
	stuff121()
	stuff122()
	stuff123()
	stuff124()
	stuff125()
	stuff126()
	stuff127()
	stuff128()
	stuff129()
	stuff130()
	stuff131()
	stuff132()
	stuff133()
	stuff134()
	stuff135()
	stuff136()
	stuff137()
	stuff138()
	stuff139()
	stuff140()
	stuff141()
	stuff142()
	stuff143()
	stuff144()
	stuff145()
	stuff146()
	stuff147()
	stuff148()
	stuff149()
	stuff150()
	stuff151()
	stuff152()
	stuff153()
	stuff154()
	stuff155()
	stuff156()
	stuff157()
	stuff158()
	stuff159()
	stuff160()
	stuff161()
	stuff162()
	stuff163()
	stuff164()
	stuff165()
	stuff166()
	stuff167()
	stuff168()
	stuff169()
	stuff170()
	stuff171()
	stuff172()
	stuff173()
	stuff174()
	stuff175()
	stuff176()
	stuff177()
	stuff178()
	stuff179()
	stuff180()
	stuff181()
	stuff182()
	stuff183()
	stuff184()
	stuff185()
	stuff186()
	stuff187()
	stuff188()
	stuff189()
	stuff190()
	stuff191()
	stuff192()
	stuff193()
	stuff194()
	stuff195()
	stuff196()
	stuff197()
	stuff198()
	stuff199()
	stuff200()
	stuff201()
	stuff202()
	stuff203()
	stuff204()
	stuff205()
	stuff206()
	stuff207()
	stuff208()
	stuff209()
	stuff210()
	stuff211()
	stuff212()
	stuff213()
	stuff214()
	stuff215()
	stuff216()
	stuff217()
	stuff218()
	stuff219()
	stuff220()
	stuff221()
	stuff222()
	stuff223()
	stuff224()
	stuff225()
	stuff226()
	stuff227()
	stuff228()
	stuff229()
	stuff230()
	stuff231()
	stuff232()
	stuff233()
	stuff234()
	stuff235()
	stuff236()
	stuff237()
	stuff238()
	stuff239()
	stuff240()
	stuff241()
	stuff242()
	stuff243()
	stuff244()
	stuff245()
	stuff246()
	stuff247()
	stuff248()
	stuff249()
	stuff250()
	stuff251()
	stuff252()
	stuff253()
	stuff254()
	stuff255()
	return 0
}
